#------------------------------------------------------------------------
# Source File Information (DO NOT MODIFY)
# Source ID: eed7641f-efe7-414e-912e-412f462d609c
# Source File: C:\VsProject\SCSMViewManager\SCSM View Manager.psproj
#------------------------------------------------------------------------
<#
    .NOTES
    --------------------------------------------------------------------------------
     Code generated by:  SAPIEN Technologies, Inc., PowerShell Studio 2016 v5.2.118
     Generated on:       4/14/2016 4:00 PM
     Generated by:       Jonatan.Bernal
    --------------------------------------------------------------------------------
    .DESCRIPTION
        Script generated by PowerShell Studio 2016
#>


#region Source: Startup.pss
#----------------------------------------------
#region Import Assemblies
#----------------------------------------------
[void][Reflection.Assembly]::Load('System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089')
[void][Reflection.Assembly]::Load('System.Data, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089')
[void][Reflection.Assembly]::Load('System.Drawing, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a')
[void][Reflection.Assembly]::Load('System.DirectoryServices, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a')
[void][Reflection.Assembly]::Load('System.ServiceProcess, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a')
#endregion Import Assemblies

function Main {
	Param ([String]$Commandline)	
	Call-View_Manager_psf
	$global:ExitCode = 0 #Set the exit code for the Packager
}#endregion Source: Startup.pss

#region Source: Globals.ps1
	#--------------------------------------------
	# Declare Global Variables and Functions here
	#--------------------------------------------
	
	<# 
	TODO:
		* Create a new "Save" button.
		* Remove the Save-XML function call from other functions.
		* Save-XML should only be called when you press the 'Save' button.
		
	CONSIDERATIONS:
		* Have the changes be saved to a temporary file, instead of only in memory.
		* Change New-SCSMFolder to work with non-Cireson Folders.
	<#
		This function will save the XML file.
	#>
	function Save-XML()
	{
		Write-Host "Saving XMl."
		$ManagementPackXml.Save($ManagementPackPath)
	}
	
	<#
		This function will query the XML file and return the DisplayString.Name property of the given ID
	#>
	function Get-SCSMStringName($ID)
	{
		return $ManagementPackXml.GetElementsByTagName("DisplayString") | ? ElementID -eq $ID | %{ $_.Name }
	}
	
	<#
		This function will query the XML file and return the ParentFolder property from the Folders object of the given ID
	#>
	function Get-SCSMFolderParent($ID)
	{
		return $ManagementPackXml.GetElementsByTagName("Folder") | ? ID -EQ $ID | %{ $_.ParentFolder }
	}
	
	<#
		This function will query the XML file and return the Folder property from the FolderItems object of the given ID
	#>
	function Get-SCSMViewFolder($ID)
	{
		return $ManagementPackXml.GetElementsByTagName("FolderItem") | ? ElementID -EQ $ID | %{ $_.Folder }
	}
	
	<#
		This function will create a new SCSM Folder ( Cireson folder only ) given the fodler name, and the parent ID where it should be saved. 
	#>
	function New-SCSMFolder($folderName, $ParentFolderID)
	{
		# Create a GUID for the new folder	
		$folderGUID = ([GUID]::NewGuid().Guid).replace("-", '')
		# Create a GUID for the first category of the new folder
		$folderCategoryGUID = ([GUID]::NewGuid().Guid).replace("-", '')
		# Create a GUID for the second category of the new folder
		$folderCategory2GUID = ([GUID]::NewGuid().Guid).replace("-", '')
		# Set the description of the new folder
		$description = "Automatically created using script - For Details inquire with Jonatan.Bernal"
		
		# Create a new XML "Folder" Element
		$xmlElement_Folder = $ManagementPackXml.CreateElement("Folder")
		# Configure the element
		$xmlElement_Folder.SetAttribute('ID', "Folder.$folderGUID")
		$xmlElement_Folder.SetAttribute('Accessibility', "Public")
		$xmlElement_Folder.SetAttribute('ParentFolder', $ParentFolderID)
		# Append the child element on the structure.
		$ManagementPackXml.ManagementPack.Presentation.Folders.AppendChild($xmlElement_Folder) | Out-Null
		
		# Create a new XML "Category" Element
		$xmlElement_FolderCategory = $ManagementPackXml.CreateElement("Category")
		# Configure the element
		$xmlElement_FolderCategory.SetAttribute("ID", "Category.$folderCategoryGUID")
		$xmlElement_FolderCategory.SetAttribute("Target", "Folder.$folderGUID")
		$xmlElement_FolderCategory.SetAttribute("Value", "View!Cireson.View.Builder.Folder.Tasks")
		# Append the child element on the structure.
		$ManagementPackXml.ManagementPack.Categories.AppendChild($xmlElement_FolderCategory) | Out-Null
		
		# Create a new XML "Category" Element
		$xmlElement_2ndFolderCategory = $ManagementPackXml.CreateElement("Category")
		# Configure the element
		$xmlElement_2ndFolderCategory.SetAttribute("ID", "Category.$folderCategory2GUID")
		$xmlElement_2ndFolderCategory.SetAttribute("Target", "Folder.$folderGUID")
		$xmlElement_2ndFolderCategory.SetAttribute("Value", "View!Cireson.View.Builder.View.Tasks")
		# Append the child element on the structure.
		$ManagementPackXml.ManagementPack.Categories.AppendChild($xmlElement_2ndFolderCategory) | Out-Null
		
		# Create a new XML "ImageReference" Element
		$xmlElement_image = $ManagementPackXml.CreateElement("ImageReference")
		# Configure the element
		$xmlElement_image.SetAttribute("ElementID", "Folder.$folderGUID")
		$xmlElement_image.SetAttribute("ImageID", "Console!Microsoft.EnterpriseManagement.ServiceManager.UI.Console.Image.Folder")
		# Append the child element on the structure.
		$ManagementPackXml.ManagementPack.Presentation.ImageReferences.AppendChild($xmlElement_image) | Out-Null
		
		# Createa a new "DisplayString" Element
		$xmlElement_DisplayName = $ManagementPackXml.CreateElement("DisplayString")
		# Configure the element
		$xmlElement_DisplayName.SetAttribute('ElementID', "Folder.$folderGUID")
		# Createa a new "Name" Element
		$xmlElement_DisplayName_Name = $ManagementPackXml.CreateElement("Name")
		# Configure the element
		$xmlElement_DisplayName_Name.InnerText = $folderName
		# Append the child element to the new "DisplayString" element.
		$xmlElement_DisplayName.AppendChild($xmlElement_DisplayName_Name) | Out-Null
		# Create a new "Description" Element
		$xmlElement_DisplayName_Description = $ManagementPackXml.CreateElement("Description")
		# Configure the element
		$xmlElement_DisplayName_Description.InnerText = $description
		# Append the child element to the new "DisplayString" element.
		$xmlElement_DisplayName.AppendChild($xmlElement_DisplayName_Name) | Out-Null
		# Append the child element on the structure. 
		$ManagementPackXml.ManagementPack.LanguagePacks.LanguagePack | ? ID -eq "ENU" | %{ $_.DisplayStrings.AppendChild($xmlElement_DisplayName) } | Out-Null
		
		# Call the 'Save-Xml' function to save the changes
		Save-XML
		
		# return the ID of the newly created folder.
		return "Folder.$folderGUID"
	} # endfunction
	
	<#
		This function will create a copy of an SCSM View. It requires that a new name, the parent ID of where the view should be stored, and the original View ID be provided.
	#>
	function Copy-SCSMView($viewName, $parentID, $originalViewID)
	{
		# Create a GUID for the new View
		$viewGUID = ([GUID]::NewGuid().Guid).replace("-", '')
		# Create a GUID for the new FolderItem
		$viewItemGUID = ([GUID]::NewGuid().Guid).replace("-", '')
		# Get the original view Object
		$xmlElement_originalView = $ManagementPackXml.ManagementPack.Presentation.Views.View | ? ID -match $originalViewID
		# Get the original view categories
		$xmlElement_originalViewCategories = $ManagementPackXml.ManagementPack.Categories.Category | ? Target -EQ $xmlElement_originalView.ID
		# Get the Original view image 
		$xmlElement_originalViewImage = $ManagementPackXml.ManagementPack.Presentation.ImageReferences.ImageReference | ? ElementID -EQ $xmlElement_originalView.ID
		# Clone the original view Element
		$xmlElement_View = $xmlElement_originalView.Clone()
		# Set the Clone ID to the new View ID
		$xmlElement_View.ID = "View.$viewGUID"
		# Append the child to "Views" 
		$ManagementPackXml.ManagementPack.Presentation.Views.AppendChild($xmlElement_View) | Out-Null
		
		foreach ($categoryObj in $xmlElement_originalViewCategories) # Loop through each of the found categories
		{
			# Create a GUID for the new category
			$viewCategoryGUID = ([GUID]::NewGuid().Guid).replace("-", '')
			# Create a "Category" Element
			$xmlElement_ViewCategory = $ManagementPackXml.CreateElement("Category")
			# Configure Element
			$xmlElement_ViewCategory.SetAttribute("ID", "Category.$viewCategoryGUID")
			$xmlElement_ViewCategory.SetAttribute("Target", "View.$viewGUID")
			$xmlElement_ViewCategory.SetAttribute("Value", $categoryObj.Value)
			# Append the child to "Categories"
			$ManagementPackXml.ManagementPack.Categories.AppendChild($xmlElement_ViewCategory) | Out-Null
		} # endloop
		
		# Create a "FolderItem" element
		$xmlElement_ViewItem = $ManagementPackXml.CreateElement("FolderItem")
		# Configure Element
		$xmlElement_ViewItem.SetAttribute('ElementID', "View.$viewGUID")
		$xmlElement_ViewItem.SetAttribute('ID', "FolderItem.$viewItemGUID")
		$xmlElement_ViewItem.SetAttribute('Folder', $parentID)
		# Append the child to "FolderITems" 
		$ManagementPackXml.ManagementPack.Presentation.FolderItems.AppendChild($xmlElement_ViewItem) | Out-Null
		
		# Create a new "ImageReference" Object
		$xmlElement_ViewImage = $ManagementPackXml.CreateElement("ImageReference")
		# Configure element
		$xmlElement_ViewImage.SetAttribute("ElementID", "View.$viewGUID")
		$xmlElement_ViewImage.SetAttribute("ImageID", $xmlElement_originalViewImage.ImageID)
		# Append the child to "ImageReferences"
		$ManagementPackXml.ManagementPack.Presentation.ImageReferences.AppendChild($xmlElement_ViewImage) | Out-Null
		
		# Createa a new "DisplayString" element
		$xmlElement_ViewDisplayName = $ManagementPackXml.CreateElement("DisplayString")
		# Configure element
		$xmlElement_ViewDisplayName.SetAttribute('ElementID', "View.$viewGUID")
		# Creata a new "Name" Element
		$xmlElement_ViewDisplayName_Name = $ManagementPackXml.CreateElement("Name")
		# Configure element
		$xmlElement_ViewDisplayName_Name.InnerText = $viewName
		# Append element to new DisplayString element
		$xmlElement_ViewDisplayName.AppendChild($xmlElement_ViewDisplayName_Name) | Out-Null
		# Create a new "Description" Element
		$xmlElement_ViewDisplayName_Description = $ManagementPackXml.CreateElement("Description")
		# Configure element
		$xmlElement_ViewDisplayName_Description.InnerText = "Automatically created using script - For Details inquire with Jonatan.Bernal"
		# Append element to new DisplayString element
		$xmlElement_ViewDisplayName.AppendChild($xmlElement_ViewDisplayName_Description) | Out-Null
		# Append element to "DisplayStrings"  
		$ManagementPackXml.ManagementPack.LanguagePacks.LanguagePack | ? ID -eq "ENU" | %{ $_.DisplayStrings.AppendChild($xmlElement_ViewDisplayName) } | Out-Null
		
		# Call the 'Save-Xml' function to save the changes
		Save-XML
		
		# return the ID of the newly created folder.  
		return "View.$viewGUID"
	} # endfunction
	
	<#
		This function will move a View to a different parent. It requires that the ID of the view and the ID of the new parent folder be provided.
	#>
	function Move-SCSMView($viewID, $newParentID)
	{
		# Get the FolderItem XML element based on the provided ID
		$xmlViewItem = $ManagementPackXml.ManagementPack.Presentation.FolderItems.FolderItem | ? ElementID -EQ $viewID
		# Update the Folder property on the element
		$xmlViewItem.Folder = $newParentID
		
		if ($xmlViewItem.Folder -eq $newParentID) # Ensure the change was performed successfully.
		{
			# Call the 'Save-Xml' function to save the changes
			Save-XML
			return $true
		} # endif
		else # if the change could not be performed
		{
			return $false
		}  # endelse
	} # endfunction
	
	<#
		This function will move a Folder to a different parent. It requires that the folder ID and the new parent folder ID be provided.
	#>
	function Move-SCSMFolder($folderID, $newParentID)
	{
		# Get the folder XML element
		$xmlFolderItem = $ManagementPackXml.ManagementPack.Presentation.Folders.Folder | ? ID -EQ $folderID
		# Upodate the parent folder property
		$xmlFolderItem.ParentFolder = $newParentID
	
		if ($xmlFolderItem.ParentFolder -eq $newParentID) # Ensure the change was performed successfully.
	
		{
			# Call the 'Save-Xml' function to save the changes
			Save-XML
			return $true
		} # endif
		else # if the change could not be performed
		{
			return $false
		} # endelse
	} # endfunction
	
	<#
		This function will remove an a View from the XML file. It requires that you provide the ID of the view that is to be removed.
		Changes performed:
			* Removes Categories Elements
			* Removes View Element
			* Removes the FolderItem Element 
			* Removes the ImageReference Element
			* Removes the DisplayString Element
	#>
	function Remove-SCSMView($viewID)
	{
		# Get a list of all the Category elements
		$Categories = $ManagementPackXml.ManagementPack.Categories
		# Get a list of all the Views
		$Views = $ManagementPackXml.ManagementPack.Presentation.Views
		# Get a list of all the FolderItems
		$FolderItems = $ManagementPackXml.ManagementPack.Presentation.FolderItems
		# Get a list of all the ImageReferences
		$ImageReferences = $ManagementPackXml.ManagementPack.Presentation.ImageReferences
		# Get a list of all the DisplayString Elements
		$DisplayStrings = $ManagementPackXml.ManagementPack.LanguagePacks.LanguagePack | ? ID -eq "ENU" | %{ $_.DisplayStrings }
		
		foreach ($category in $Categories.Category) # Loop through each category
		{
			if ($category.Target -eq $viewID) # Find the one that contains the ViewID
			{
				# Remove the Category
				$Categories.RemoveChild($category)
			} # endif
		} # endloop
		
		foreach ($view in $Views.View) # Loop through each view
		{
			if ($view.ID -eq $viewId) # Find the one that contains the ViewID
	
			{
				# Remove the View
				$Views.RemoveChild($view)
			} # endif
		} # endloop
		
		foreach ($FolderItem in $FolderItems.FolderItem) # Loop through each FolderItem
		{
			if ($FolderItem.ElementID -eq $viewId) # Find the one that contains the ViewID
			{
				# Remove the FolderItem
				$FolderItems.RemoveChild($FolderItem)
			} # endif
		} # endloop
		
		foreach ($ImageReference in $ImageReferences.ImageReference) # Loop through each ImageReference
		{
			if ($ImageReference.ElementID -eq $viewId) # Find the one that contains the ViewID
			{
				# Remove the ImageReference
				$ImageReferences.RemoveChild($ImageReference)
			} # endif
		} # endloop
		
		foreach ($DisplayString in $DisplayStrings.DisplayString) # Loop through each DisplayString
		{
			if ($DisplayString.ElementID -eq $viewId) # Find the one that contains the ViewID
			{
				# Remove the DisplayString
				$DisplayStrings.RemoveChild($DisplayString)
			} # endif
		} # endloop
		
		# Call the 'Save-Xml' function to save the changes
		Save-XML
	}
	
	<#
		This function will remove an a Folder from the XML file. It requires that you provide the ID of the folder that is to be removed.
		Changes performed:
			* Removes Categories Elements
			* Removes Folder Element
			* Removes the FolderItem Element 
			* Removes the ImageReference Element
			* Removes the DisplayString Element
	#>
	function Remove-SCSMFolder($folderID)
	{
		# Get a list of all the Category elements
		$Categories = $ManagementPackXml.ManagementPack.Categories
		# Get a list of all the Folders
		$Folders = $ManagementPackXml.ManagementPack.Presentation.Folders
		# Get a list of all the FolderItems
		$FolderItems = $ManagementPackXml.ManagementPack.Presentation.FolderItems
		# Get a list of all the ImageReferences
		$ImageReferences = $ManagementPackXml.ManagementPack.Presentation.ImageReferences
		# Get a list of all the DisplayString Elements
		$DisplayStrings = $ManagementPackXml.ManagementPack.LanguagePacks.LanguagePack | ? ID -eq "ENU" | %{ $_.DisplayStrings }
		
		foreach ($category in $Categories.Category) # Loop through each Folder
		{
			if ($category.Target -eq $folderID) # Find the one that contains the folderID
			{
				# Remove the Folder
				$Categories.RemoveChild($category)
			} # endif
		} # endloop
		
		foreach ($Folder in $Folders.Folder) # Loop through each Folder
		{ 
			if ($Folder.ID -eq $folderID) # Find the one that contains the folderID
			{
				# Remove the Folder
				$Folders.RemoveChild($Folder)
			} # endif
		} # endloop
		
		foreach ($FolderItem in $FolderItems.FolderItem) # Loop through each FolderItem
		{
			if ($FolderItem.Folder -eq $folderID) # Find the one that contains the folderID
			{
				if ($FolderItem.ElementID -like "View.*") # If the FolderItem is a view
				{
					# Call 'Remove-SCSMView' to remove the view from the XML file
					Remove-SCSMView -viewID $FolderItem.ElementID
				} # endif
				elseif ($FolderItem.ElementId -like "Folder.*") # IF the FolderItem is a folder
				{
					# Call 'Remove-SCSMFolder' to remove the folder and its subitems from the XML file
					Remove-SCSMFolder -folderID $FolderItem.ElementID
				} # endelse
			} # endif
		} # endloop
		
		foreach ($ImageReference in $ImageReferences.ImageReference) # Loop through each ImageReference
		{
			if ($ImageReference.ElementID -eq $folderID) # Find the one that contains the folderID
			{
				# Remove the ImageReference
				$ImageReferences.RemoveChild($ImageReference)
			} # endif
		} # endloop
		
		foreach ($DisplayString in $DisplayStrings.DisplayString) # Loop through each DisplayString
		{
			if ($DisplayString.ElementID -eq $folderID) # Find the one that contains the folderID
			{
				# Remove the DisplayString
				$DisplayStrings.RemoveChild($DisplayString)
			} # endif
		} # endloop
		
		# Call the 'Save-Xml' function to save the changes
		Save-XML
	}
	
	<#
		This function will rename the SCSM Object. This requires that the Object ID and the new name is provided.
	#>
	function Rename-SCSMObject($objectID, $newName)
	{
		# Find the XML element equals to the provided ID
		$selectedItemNameElement = $ManagementPackXml.ManagementPack.LanguagePacks.LanguagePack | ? ID -eq "ENU" | %{ $_.DisplayStrings.DisplayString } | ? ElementID -EQ $objectID
		# Update the name property of the element
		$selectedItemNameElement.Name = $newName
		# Call the 'Save-Xml' function to save the changes
		Save-XML
	} # endfunction#endregion Source: Globals.ps1

#region Source: View Manager.psf
function Call-View_Manager_psf
{
	#----------------------------------------------
	#region Import the Assemblies
	#----------------------------------------------
	[void][reflection.assembly]::Load('System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089')
	[void][reflection.assembly]::Load('System.Data, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089')
	[void][reflection.assembly]::Load('System.Drawing, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a')
	[void][reflection.assembly]::Load('System.DirectoryServices, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a')
	[void][reflection.assembly]::Load('System.ServiceProcess, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a')
	[void][reflection.assembly]::Load('System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a')
	#endregion Import Assemblies

	#----------------------------------------------
	#region Generated Form Objects
	#----------------------------------------------
	[System.Windows.Forms.Application]::EnableVisualStyles()
	$SCSM_ViewManager = New-Object 'System.Windows.Forms.Form'
	$loadingBar = New-Object 'System.Windows.Forms.ProgressBar'
	$propertygrid1 = New-Object 'System.Windows.Forms.PropertyGrid'
	$statusbar1 = New-Object 'System.Windows.Forms.StatusBar'
	$ManagementPackViews = New-Object 'System.Windows.Forms.TreeView'
	$menustrip1 = New-Object 'System.Windows.Forms.MenuStrip'
	$fileToolStripMenuItem = New-Object 'System.Windows.Forms.ToolStripMenuItem'
	$loadManagementPackToolStripMenuItem = New-Object 'System.Windows.Forms.ToolStripMenuItem'
	$unloadManagementPackToolStripMenuItem = New-Object 'System.Windows.Forms.ToolStripMenuItem'
	$exitToolStripMenuItem = New-Object 'System.Windows.Forms.ToolStripMenuItem'
	$viewContextMenu = New-Object 'System.Windows.Forms.ContextMenuStrip'
	$folderContextMenu = New-Object 'System.Windows.Forms.ContextMenuStrip'
	$editToolStripMenuItem = New-Object 'System.Windows.Forms.ToolStripMenuItem'
	$viewToolStripMenuItem = New-Object 'System.Windows.Forms.ToolStripMenuItem'
	$folderToolStripMenuItem = New-Object 'System.Windows.Forms.ToolStripMenuItem'
	$copyViewToolStripMenuItem = New-Object 'System.Windows.Forms.ToolStripMenuItem'
	$copyViewMainToolStripMenuItem = New-Object 'System.Windows.Forms.ToolStripMenuItem'
	$newFolderToolStripMenuItem = New-Object 'System.Windows.Forms.ToolStripMenuItem'
	$cloneFolderMainToolStripMenuItem = New-Object 'System.Windows.Forms.ToolStripMenuItem'
	$toolstripseparator2 = New-Object 'System.Windows.Forms.ToolStripSeparator'
	$deleteViewMainToolStripMenuItem = New-Object 'System.Windows.Forms.ToolStripMenuItem'
	$deleteFolderToolStripMenuItem = New-Object 'System.Windows.Forms.ToolStripMenuItem'
	$deleteFolderMainToolStripMenuItem1 = New-Object 'System.Windows.Forms.ToolStripMenuItem'
	$deleteViewToolStripMenuItem = New-Object 'System.Windows.Forms.ToolStripMenuItem'
	$renameViewMainToolStripMenuItem = New-Object 'System.Windows.Forms.ToolStripMenuItem'
	$renameFolderMainToolStripMenuItem = New-Object 'System.Windows.Forms.ToolStripMenuItem'
	$renameViewToolStripMenuItem = New-Object 'System.Windows.Forms.ToolStripMenuItem'
	$renameFolderToolStripMenuItem = New-Object 'System.Windows.Forms.ToolStripMenuItem'
	$newFolderMainToolStrip = New-Object 'System.Windows.Forms.ToolStripMenuItem'
	$newFolderToolStrip = New-Object 'System.Windows.Forms.ToolStripMenuItem'
	$newFolderFromTemplateToolStripMenuItem = New-Object 'System.Windows.Forms.ToolStripMenuItem'
	$imagelist1 = New-Object 'System.Windows.Forms.ImageList'
	$InitialFormWindowState = New-Object 'System.Windows.Forms.FormWindowState'
	#endregion Generated Form Objects

	#----------------------------------------------
	# User Generated Script
	#----------------------------------------------
	#region Global Variables
	# Creates a global variable used to store the Management Pack Path
	New-Variable -Name ManagementPackPath -Scope Global
	# Creates a global variable used to store the Management Pack XML data
	New-Variable -Name ManagementPackXml -Scope Global
	#endregion
	
	<#
		This function is used to GEt the SCSM Views currently located on the Management Pack XML. 
		The function requires that you provide the ID of the Parent folder, and the Parent Node where the views will be added to. 
	#>
	function Get-SCSMViews($id, $parentNode)
	{
		# Variable used to store all of the views that have the parentID that was received on the parameter
		$views = $ManagementPackXml.ManagementPack.Presentation.FolderItems.FolderItem | ? ElementID -Like "View.*" | ? Folder -eq $id
		foreach ($view in $views) # Loop through the Views that were found
		{
			# Create a new TreeNode object
			$currentNode = New-Object System.Windows.Forms.TreeNode
			# Query the XML file to get the DisplayString.Name value and store it on a temporary variable.
			$tempViewName = Get-SCSMStringName -ID $view.ElementID
			# Configure the Node information.
			$currentNode.Name = $tempViewName
			$currentNode.Text = $tempViewName
			$currentNode.Tag = $view.ElementID
			$currentNode.ImageIndex = 2
			$currentNode.SelectedImageIndex = $currentNode.ImageIndex
			$currentNode.ContextMenuStrip = $viewContextMenu
			# Add the new Node to the parent Node provided in the Parameter.
			$parentNode.Nodes.Add($currentNode)
		} # endloop
	} # endfunction
	
	<#
		This function will be used to get the SCSM Folders currently located on the Management Pack XML.
		The function will require that you provide the ID of the Parent folder, and the Parent  Node where the folders will be added to.
	#>
	function Get-SCSMSubfolders($id, $parentNode)
	{
		# Variable used to store all of the subfolders that are found to have the same Parent Folder ID received from the parameters
		$subfolders = $ManagementPackXml.ManagementPack.Presentation.Folders.Folder | ? ParentFolder -Match $id
		if ($subfolders -ne $null) # Ensure that the folder does have subfolders.
		{
			foreach ($folder in $subfolders) # Loop through the Folders that were found.
			{
				# Create a new TreeNode Object
				$currentNode = New-Object System.Windows.Forms.TreeNode
				# Query the XML file to get the DisplayString.Name value and store it on a temporary variable.
				$tempFolderName = Get-SCSMStringName -ID $folder.ID
				# Configure the Node information.
				$currentNode.Name = $tempFolderName
				$currentNode.Text = $tempFolderName
				$currentNode.Tag = $folder.ID
				$currentNode.ImageIndex = 0
				$currentNode.ContextMenuStrip = $folderContextMenu
				# Add the new Node to the parent Node provided in the Parameter.
				$parentNode.Nodes.Add($currentNode)
				# Change the Status Bar information to give a sense of progress.
				$statusbar1.Text = "ManagementPack :: Loading Management Pack Data :: Gathering data on $tempFolderName."
				<#
					This function was used recursively in the past but the idea was scrapped due to performance issues.
					This area was commented to remove the recursive feature.
				
					Get-SCSMSubfolders -id $folder.ID -parentNode $currentNode
					Get-SCSMViews -id $folder.ID -parentNode $currentNode
				#>
			} # endloop
		} # endif
	} # endfunction
	
	<#
		This function is used to load the core information on the TreeView.
	#>
	function Load-TreeView()
	{
		if ($ManagementPackXml.GetElementsByTagName("Folders") -ne $null) # Ensure that the management pack loaded contains 'Folders' items. 
		{
			# Set the status bar to notify the user that the data is being loaded.
			$statusbar1.Text = "ManagementPack :: Loading Management Pack Data"
			# Disable the View Manager form so that the users cannot click on things while data is loading.
			$SCSM_ViewManager.Enabled = $false
			# Show the Loading bar
			$loadingBar.Visible = $true
			# Get the root folders from the XML File. Root files can be adentified because they contain the parent folder 'ServiceManager.Console'
			$rootFolders = $ManagementPackXml.ManagementPack.Presentation.Folders.Folder | ? ParentFolder -Match "!ServiceManager"
			# Display the number of root folders found in the status bar.
			$statusbar1.Text = "ManagementPack :: Loading Management Pack Data :: $($rootFolders.length) have been found."
			# Increment the loading bar to show that the first step was taken.
			$loadingBar.Increment(10)
			<#
				TODO:This function was designed to start with the root folders because it was required for the recursion. 
				Since recursion has been removed this function can be modified to no longer start with the root folders and move to the 'Get-SCSMSubFolders' functions right away.
			#>
			foreach ($folder in $rootFolders) # Loop through each of the root folders.
			{
				# Create a new TreeNode Object
				$currentNode = New-Object System.Windows.Forms.TreeNode
				# Query the XML file to get the DisplayString.Name value and store it on a temporary variable.
				$tempFolderName = Get-SCSMStringName -ID $folder.ID
				# Configure the Node information.
				$currentNode.Name = $tempFolderName
				$currentNode.Text = $tempFolderName
				$currentNode.Tag = $folder.ID
				$currentNode.ImageIndex = 0
				$currentNode.SelectedImageIndex = $currentNode.ImageIndex
				$currentNode.ContextMenuStrip = $folderContextMenu
				# Add the new Node to the ManagementPackViews.Nodes property (This is the root section).
				$ManagementPackViews.Nodes.Add($currentNode)
				# Increase the loading bar by 90 (this is 90 because we already increased by 10 before) divided by the number of root folders found.
				$loadingBar.Increment(90/$rootFolders.length)
				# Note the status bar with the progress.
				$statusbar1.Text = "ManagementPack :: Loading Management Pack Data :: Gathering data on $tempFolderName."
				
				<#
					This function was used recursively in the past but the idea was scrapped due to performance issues.
					This area was commented to remove the recursive feature.
				
					Get-SCSMSubfolders -id $folder.ID -parentNode $currentNode
					Get-SCSMViews -id $folder.ID -parentNode $currentNode
				#>			
				
			} # endloop 		
			# Acknowledge completion on Status bar
			$statusbar1.Text = "ManagementPack :: Loading complete."
			# Expand the Nodes.
			$ManagementPackViews.ExpandAll()
			# Reset the loading bar 
			$loadingBar.Value = 0
			# Hide the Loading bar as it is no longer needed.
			$loadingBar.Visible = $false
			# Now that the data is loaded enable the form again.
			$SCSM_ViewManager.Enabled = $true
			# Update the status bar.
			$statusbar1.Text = "ManagementPack :: Data Loaded"
		} # endif
		else # If there is no 'Folders' items return an error
		{
			# Error to be displayed if no Folders Items were found.
			[System.Windows.Forms.MessageBox]::Show("No folder structure found!", 'Management Pack Failure', 'OK', 'Error')
			# Update the status bar.
			$statusbar1.Text = "ManagementPack :: ERROR."
		} # endelse
	} # endfunction
	
	<#
		This function will be used to refresh the node when a View you copy a view. 
		This function was deprecated due to performance issues
	#>
	function Refresh-TreeViewNode($nodeToRefresh)
	{
		foreach ($node in $nodeToRefresh.Nodes) # Loop through the subnodes of the node we want to refresh.
		{
			# Remove the child nodes.
			$ManagementPackViews.SelectedNode.Parent.Nodes.RemoveAt($node.Index)
		} # endloop
		
		<#
			This is no longer needed because empty nodes are reloaded again automatically.
		
			Load the nodes once again using the 'Get-SCSMView' function.
			Get-SCSMViews -id $nodeToRefresh.Tag -parentNode $nodeToRefresh
		#>
	} # endfunction
	
	<#
		This function will create a copy of the SCSMView that is selected.
	 	The function will call the EnterNewViewName form to get a new name.
	#>
	function Copy-ViewAction()
	{
		if ((Call-EnterNewViewName_psf) -eq 'OK') # Check if the Call-EnterNewViewName function ended with an 'OK'
		{
			# Get the new view name from the EnterNewViewName form textbox.
			$newViewName = $EnterNewViewName_newName_txtBox
			# Get the Parent Tag of the selected Node (The parent folder of the view)
			$parentNode = $ManagementPackViews.SelectedNode.Parent
			$parentID = $ManagementPackViews.SelectedNode.Parent.Tag
			# Get the ID of the View that was selected 
			$selectedViewID = $ManagementPackViews.SelectedNode.Tag
			# Copy the View on the XML File, and save the return new View ID. 
			$newViewID = Copy-SCSMView -viewName $newViewName -parentID $parentID -originalViewID $selectedViewID
			# Create a new Node object
			$newChildNode = New-Object System.Windows.Forms.TreeNode
			$newNodeName = $newViewName
			# Configure the new Node
			$newChildNode.Name = $newNodeName
			$newChildNode.Text = $newNodeName
			$newChildNode.Tag = $newViewID
			$newChildNode.ImageIndex = 0
			$newChildNode.ContextMenuStrip = $viewContextMenu
			# Add the new Node
			$parentNode.Nodes.Add($newChildNode)
			<#
				For performance issues we stop refreshing the parent node from XML and simply add the newly created item to the treeview.
			
				# Refresh the Parent Node to find the newly created View.
				Refresh-TreeViewNode $ManagementPackViews.SelectedNode.Parent
			#>
		} # endif
	} # endfunction
	
	<#
		This function is used to clone a folder and its subitems.
		This function will require that you send as parameters the node that you want to close and the parent node that will contain the newly created folder.
	#>
	function Clone-Folder($nodeToClone, $parentNode)
	{
		# Create a variable to store the name of the node to clone
		$folderName = $nodeToClone.Name
		# Create the SCSM Folder on the XML and save the new ID.
		$result = New-SCSMFolder -folderName $folderName -ParentFolderID $parentNode.Tag
		# Create a new Node object.
		$newNode = New-Object System.Windows.Forms.TreeNode
		# Configure the new node
		$newNode.Name = Get-SCSMStringName -ID $result
		$newNode.Text = Get-SCSMStringName -ID $result
		$newNode.Tag = $result
		$newNode.ImageKey = 0
		$newNode.ContextMenuStrip = $folderContextMenu
		# Add the new node
		$parentNode.Nodes.Add($newNode)
		# Get the newly created node object
		$newParentNode = $parentNode.Nodes | ? Tag -EQ $result
		# Get the child nodes of the original Node
		$childNodes = $nodeToClone.Nodes
		foreach ($node in $childNodes) # Loop through each of the subitems
		{
			if ($node.Tag -like "View.*") # Check if the item is a View
			{
				# Make a copy of the SCSM View on the XML file.
				$newViewID = Copy-SCSMView -viewName $node.Name -parentID $result -originalViewID $node.Tag
				# Create a new Node object
				$newChildNode = New-Object System.Windows.Forms.TreeNode
				# Configure the new Node
				$newChildNode.Name = Get-SCSMStringName -ID $newViewID
				$newChildNode.Text = Get-SCSMStringName -ID $newViewID
				$newChildNode.Tag = $newViewID
				$newChildNode.ImageIndex = 0
				$newChildNode.ContextMenuStrip = $viewContextMenu
				# Add the new Node
				$newNode.Nodes.Add($newChildNode)
			} # endif
			else # If the item is not a view
			{
				# Recurse the function to close the folder and any subitems.
				Clone-Folder -nodeToClone $node -parentNode $newParentNode
			}
		} # endloop
		# Expand all the newly node.
		$newNode.ExpandAll()
		# Select the new Node.
		$ManagementPackViews.SelectedNode = $newNode
	} # endfunction
	
	<#
		This function will be used to remove a View
	#>
	function Remove-View()
	{
		# Double check that you wish to remove the view.
		$response = [System.Windows.Forms.MessageBox]::Show("Are you sure you want to delete $($ManagementPackViews.SelectedNode.Name)?", 'Confirm', 'OKCancel', 'Question')
		if ($response -eq [System.Windows.Forms.DialogResult]::OK) # if the answer is OK continue
		{
			# Call 'Remove-SCSMView' function to remove the view from the XML File
			Remove-SCSMView -viewId $ManagementPackViews.SelectedNode.Tag
			# Remove the selected node from the TreeView
			$ManagementPackViews.SelectedNode.Remove()
		} # endif
	} # endfunction
	
	<#
		This function will be used to remove a Folder and its subitems
	#>
	function Remove-Folder()
	{
		# Double check that you wish to remove the folder
		$response = [System.Windows.Forms.MessageBox]::Show("Are you sure you want to delete $($ManagementPackViews.SelectedNode.Name)?", 'Confirm', 'OKCancel', 'Question')
		if ($response -eq [System.Windows.Forms.DialogResult]::OK) # IF the answer is OK Continue
		{
			# Call 'Remove'SCSMFolder' which will remove the folder and all its subitems from the XML file
			Remove-SCSMFolder -folderID $ManagementPackViews.SelectedNode.Tag
			# Remove the selected node which will remove the selected folder and its subitems from the TreeView
			$ManagementPackViews.SelectedNode.Remove() 
		} # endif
	} # endfunction
	
	<#
		Create a new empty folder
	#>
	function New-Folder()
	{
		if ((Call-EnterNewName_psf) -eq 'OK') # Ensure that you press OK on the new folder name
		{
			# Save the name from the EnterName function 
			$folderName = $EnterNewName_newName_TxtBox
			# Save the selected Node as the ParentNode
			$parentNode = $ManagementPackViews.SelectedNode
			# Call the 'New-SCSMFolder' function which will create the folder on the XML file and save the return ID.
			$newFolderID = New-SCSMFolder -folderName $folderName -ParentFolderID $parentNode.Tag
			if ($newFolderID -ne $null) # Ensure that the ID is no Empty which would indicate an issue when creating the folder
			{
				# Create a new Node object
				$newNode = New-Object System.Windows.Forms.TreeNode
				# Configure the new Node
				$newNode.Text = $folderName
				$newNode.Name = $folderName
				$newNode.Tag = $newFolderID
				$newNode.ImageIndex = 0
				$newNode.ContextMenuStrip = $folderContextMenu
				# Add the new Node to the parent node
				$ManagementPackViews.SelectedNode.Nodes.Add($newNode)
				# Expand the new Node
				$ManagementPackViews.ExpandAll()
			}
		} # endif
	} # endfunction
	
	<#
		This function will rename the selected item to the given name
	#>
	function Rename-Item()
	{
		if ((Call-EnterNewName_psf -selectedNodeName $ManagementPackViews.SelectedNode.Text ) -eq 'OK') # Ensure that you select OK on the new name
		{
			# Save the new name onto a variable
			$newName = $EnterNewName_newName_TxtBox
			# Call the'Rename-SCSMObject' function which will rename the function on the XML File
			Rename-SCSMObject -objectID $ManagementPackViews.SelectedNode.Tag $newName
			# Rename the Node object
			$ManagementPackViews.SelectedNode.Name = $newName
			$ManagementPackViews.SelectedNode.Text = $newName
			# Call the 'Populate-Properties' function which will update the properties on the right side panel.
			Populate-Properties
		} # endif
	} # endfunction
	
	<#
		This function will gather the properties of the selected item and fill out the informaiton on the right side panel.
	#>
	function Populate-Properties()
	{
		# Hide the toolbar from the PropertyGrid
		$propertygrid1.ToolbarVisible = $false
		#region PropertyViewClass			
		<#
			This section contains a custom class that will be used to propertly use the PropertyGrid
		#>
		$source = @"
using System;
using System.Drawing;
using System.ComponentModel;
using System.Windows.Forms;
using System.Globalization;

namespace propertyGridOjects
{
	public class selectedSCSMView{
		string _viewID = string.Empty;		
		string _viewName = string.Empty;
		string _folderID = string.Empty;
		string _folderName = string.Empty;

		public selectedSCSMView(string objID, string objName, string parentID, string parentName)
		{
			this.ViewID = objID;
			this.ViewName = objName;
			this.FolderID = parentID;
			this.FolderName = parentName;
		}

		[CategoryAttribute("View Details")]
		public string ViewID
		{
			get {return _viewID;}
			set { _viewID = value; }
		}

		[CategoryAttribute("View Details")]
		public string ViewName
		{
			get {return _viewName;}
			set { _viewName = value; }
		}

		[CategoryAttribute("Folder Details")]
		public string FolderID
		{
			get {return _folderID;}
			set { _folderID = value; }
		}

		[CategoryAttribute("Folder Details")]
		public string FolderName
		{
			get {return _folderName;}
			set { _folderName = value; }
		}
	}

	public class selectedSCSMFolder{
		string _folderID = string.Empty;
		string _folderName = string.Empty;
		string _parentID = string.Empty;
		string _parentName = string.Empty;

		public selectedSCSMFolder(string objID, string objName, string parentID, string parentName)
		{
			this.FolderID = objID;
			this.FolderName = objName;
			this.ParentID = parentID;
			this.ParentName = parentName;
		}

		[CategoryAttribute("Folder Details")]
		public string FolderID
		{
			get {return _folderID;}
			set { _folderID = value; }
		}

		[CategoryAttribute("Folder Details")]
		public string FolderName
		{
			get {return _folderName;}
			set { _folderName = value; }
		}

		[CategoryAttribute("Parent Folder Details")]
		public string ParentID
		{
			get {return _parentID;}
			set { _parentID = value; }
		}

		[CategoryAttribute("Parent Folder Details")]
		public string ParentName
		{
			get {return _parentName;}
			set { _parentName = value; }
		}
	}
}
"@
		#endregion	
		# Add the new class type to memory
		Add-Type -ReferencedAssemblies ("C:\Windows\Microsoft.Net\assembly\GAC_MSIL\System.Windows.Forms\v4.0_4.0.0.0__b77a5c561934e089\System.Windows.Forms.dll") -Language CSharp -TypeDefinition $source
		# Save the Selected Node ID
		$selectedNodeID = $ManagementPackViews.SelectedNode.Tag
		# SAve the Selected Node Name
		$selectedObjName = $ManagementPackViews.SelectedNode.Text
		if ($selectedNodeID.ToString().Contains("View.")) # Check if the selected node is a view
		{
			# Get the ID of the parent of the View.
			$selectedObjFolderID = Get-SCSMViewFolder -ID $selectedNodeID
			# Get the name of the parent of the View.
			$selectedObjFolder = Get-SCSMStringName $selectedObjFolderID
			# Create an propertyGrid  Object with the given information
			$selectedObjPropertyObj = New-Object propertyGridOjects.selectedSCSMView -ArgumentList @($selectedNodeID, $selectedObjName, $selectedObjFolderId, $selectedObjFolder)
		} # endif
		else # If the selected node is not a view
		{
			# Get the ID of the parent of the Folder. 
			$selectedObjFolderId = Get-SCSMFolderParent -ID $selectedNodeID
			# Get the name of the parent of the Folder.
			$selectedObjFolder = Get-SCSMStringName $selectedObjFolderID
			if ($selectedObjFolder -eq $null) # Check if the SelectedObjFolder is null
			{
				# If the variable is null then we set it to Root folder.
				$selectedObjFolder = "Root folder"
			} # endif
			# Create an propertyGrid  Object with the given information
			$selectedObjPropertyObj = New-Object propertyGridOjects.selectedSCSMFolder -ArgumentList @($selectedNodeID, $selectedObjName, $selectedObjFolderId, $selectedObjFolder)
		} # endelse
		# Add the object to the PropertyGrid
		$propertygrid1.SelectedObject = $selectedObjPropertyObj
	} # endfunction
	
	<#
		This function will be used to create a folder from a precreated template folder,
		naming for the folder and its subitems will follow the same pattern.
	#>
	function Create-FolderFromTemplate()
	{
		if ((Call-EnterNewName_psf $ManagementPackViews.SelectedNode.Name) -eq 'OK') # Ensure that you select OK on the EnterNewName form
		{
			# Save the selectedNode object to variable
			$parentNode = $ManagementPackViews.SelectedNode
			# Get the template folder object, keep in mind that the folder and its sub items will require to have the 'TemplateFolder' in the name.
			$templateNode = $ManagementPackViews.Nodes.Find('TemplateFolder', $true)
			if ($templateNode -ne $null) # Checks if the template folder is found.
			{
				# Clone the Template folder to the given location. (The selected node.)
				Clone-Folder -nodeToClone $templateNode -parentNode $parentNode
				# The new folder will be selected, and we want to save that object to a variable.
				$newNodeObject = $ManagementPackViews.SelectedNode
				# We get the new name of the folder structure from the EnterNewName.textbox
				$newName = $EnterNewName_newName_TxtBox
				# Call the 'Rename-SCSMObject' function to rename the folder in the XML file
				Rename-SCSMObject -objectID $newNodeObject.Tag -newName $newName
				# Rename the Nodes Name and Text to the new name
				$newNodeObject.Name = $newName
				$newNodeObject.Text = $newName
				# Reload the properties to reflect the new name
				Populate-Properties
				# Get the child nodes of the folder
				$childNodes = $newNodeObject.Nodes
				foreach ($child in $childNodes) # Loop through the child nodes of the new folder
				{
					# Create the new name by replacing the 'TemplateFolder' part of the name to the given name, and save it to a temporary variable
					$tempNodeName = $child.Name.Replace("TemplateFolder", $newNodeObject.Name)
					# Call 'Rename-SCSMObject' to rename the item to the new given name
					Rename-SCSMObject -objectID $child.Tag -newName $tempNodeName
					# Rename the Nodes name and text to the new name
					$child.Name = $tempNodeName
					$child.Text = $tempNodeName
				} # endloop
			} # endif
			else # If the template folder is not found, throws an error message.
			{
				[System.Windows.Forms.MessageBox]::Show('Format Folder not found!', 'Error creating folder', 'OK', 'Error')
			} # endelse
		} # endif
	} # endfunction
	
	<#
		Load event
	#>
	$SCSM_ViewManager_Load = {
	} # endevent
	
	<#
		Click Event to "Load Management Pack"
	#>
	$loadManagementPackToolStripMenuItem_Click = {
		if ($ManagementPackXml -eq $null)
		{
			# Create a new OpenFileDialog object
			$dialog = New-Object System.Windows.Forms.OpenFileDialog
			# Configure the dialog object
			$dialog.DefaultExt = '.xml' # .XML as the default extension
			$dialog.Filter = 'ManagementPacks|*.xml|All Files|*.*' # Configure the filter drop down
			$dialog.FilterIndex = 0 # Mark the default filter
			$dialog.InitialDirectory = $HOME # Set the default directory
			$dialog.Multiselect = $false # Disable the ability to select multiple files
			$dialog.RestoreDirectory = $true # Restore the Directory on every load
			$dialog.Title = "Select the Management Pack to Load" # Title of the window
			$dialog.ValidateNames = $true # Validate that the names are correct ( I.E. Does not contain illegal characters )
			# Show the diaglog
			if (($dialog.ShowDialog()) -eq 'OK') # Check if the user pressed OK
			{
				# Save the value to the global variable
				Set-Variable -Name ManagementPackPath -Value $dialog.FileName -Scope Global
				
				if ($managementPackPath -like "*.xml") # Ensure that the file is an .xml file
				{
					# Get the content of the XML file and save it to the global variable
					Set-Variable -Name ManagementPackXml -Value $([xml](Get-Content -Path $ManagementPackPath -Encoding UTF8)) -Scope Global
					# Update the status bar
					$statusbar1.Text = "ManagementPack :: Loaded"
					# Call the 'Load-Treeview' function
					Load-TreeView
				} # endif
				else # if the file is not an xml file send an error.
				{
					# Set the global variable to null
					Set-Variable -Name ManagementPackPath -Value $null -Scope Global
					# Send error Message
					[System.Windows.Forms.MessageBox]::Show('Selected file is the wrong format!', 'Failed to load Management Pack', 'OK', 'Error')
					# Update Status bar
					$statusbar1.Text = "ManagementPack :: FailedToLoad"
				} # endelse
			} # endif
		}
		else
		{
			[System.Windows.Forms.MessageBox]::Show("You have already loaded a management pack!`nUnload it before loading a new one.", 'Failed to load Management Pack', 'OK', 'Error')
		}
	} # endevent
	
	<#
		Click Event on Unload Management Pack
	#>
	$unloadManagementPackToolStripMenuItem_Click = {
		# Set global variables to null
		Set-Variable -Name ManagementPackPath -Value $null -Scope Global
		Set-Variable -Name ManagementPackXml -Value $null -Scope Global
		# Clear all of the nodes of the TreeView
		$ManagementPackViews.Nodes.Clear()
		$ManagementPackViews.Refresh()
		# Set the properties to null
		$propertygrid1.SelectedObjects = $null
		# Update status bar
		$statusbar1.Text = "ManagementPack :: Unloaded"
	} # endevent
	
	<#
		X Close window
	#>
	$exitToolStripMenuItem_Click={
		# Close the Window
		$SCSM_ViewManager.Close()
	}
	
	<#
		AfterSelect event on the TreeView nodes
	#>
	$ManagementPackViews_AfterSelect=[System.Windows.Forms.TreeViewEventHandler]{
		#Event Argument: $_ = [System.Windows.Forms.TreeViewEventArgs]
		# Get the Selected node
		$selectedNode = $ManagementPackViews.SelectedNode
		if ($selectedNode.Nodes.Count -eq 0) # If the selected node is not eq 0 
		{
			# Call 'Get-SCSMSubfolders' function to load any subfolders of the selected node
			Get-SCSMSubfolders -id $selectedNode.Tag -parentNode $selectedNode
			# Call 'Get-SCSMSViews' function to load any Views of the selected node
			Get-SCSMViews -id $selectedNode.Tag -parentNode $selectedNode
			# Expand the node
			$selectedNode.Expand()
			if ($selectedNode.Tag -like "View.*") # Check if the selected node is a View 
			{
				# Set the image index to 2 to identify the object as a view
				$selectedNode.ImageIndex = 2
				$selectedNode.SelectedImageIndex = $selectedNode.ImageIndex
			} # endif
			else # If the selected node is not a view
			{
				# Set the image index to 1 to identify the object as an open folder
				$selectedNode.ImageIndex = 1
				$selectedNode.SelectedImageIndex = $selectedNode.ImageIndex
			} # endelse
		} # endif
		# Call 'Populate-Properties' to refresh the properties.
		Populate-Properties
	} # endevent
	
	<#
		Click Event on Node
	#>
	$ManagementPackViews_NodeMouseClick=[System.Windows.Forms.TreeNodeMouseClickEventHandler]{
		#Event Argument: $_ = [System.Windows.Forms.TreeNodeMouseClickEventArgs]
		# Select the node where you clicked.
		$ManagementPackViews.SelectedNode = $_.Node
	} # endevent
	
	<#
		Click Event on Copy View menuToolStrip
	#>
	$copyViewToolStripMenuItem_Click = {
		Copy-ViewAction
	}
	
	<#
		Click Event on Copy Main View menuToolStrip
	#>
	$copyViewMainToolStripMenuItem_Click={
		Copy-ViewAction
	}
	
	<#
		Drag event on Node 
	#>
	$ManagementPackViews_ItemDrag = [System.Windows.Forms.ItemDragEventHandler]{
		#Event Argument: $_ = [System.Windows.Forms.ItemDragEventArgs]
		$ManagementPackViews.DoDragDrop($_.Item, [System.Windows.Forms.DragDropEffects]::Move)
	}
	
	<#
		DragDrop event 
	#>
	$ManagementPackViews_DragDrop=[System.Windows.Forms.DragEventHandler]{
		#Event Argument: $_ = [System.Windows.Forms.DragEventArgs]
		if ($_.Data.GetDataPresent("System.Windows.Forms.TreeNode", $false)) # ensure that the object being dragged is a TreeNode
		{
			# Get the node on the drop position
			$position = $ManagementPackViews.PointToClient((New-Object System.Drawing.Point($_.X, $_.Y)))
			$destinationNode = $ManagementPackViews.GetNodeAt($position)
			# Create a Node from the Parameter
			$newNode = $_.Data.GetData("System.Windows.Forms.TreeNode")
			<#
				Check the following:
					DestinationNode is not a View
					DestinationNode is not the same as the current folder 
					DestinationNode is not a subfolder of the parent node
			#>
			if (($destinationNode.Tag -notlike "View.*") -and ($destinationNode.Tag -ne $newNode.Tag) -and ($newNode.Nodes -notcontains $destinationNode))
			{
				if ($newNode.Tag -like "View.*") # Checks if the node being moved is a view
				{
	 				if (Move-SCSMView -viewID $newNode.Tag -newParentID $destinationNode.Tag) # Performs a move by calling 'Move-SCSMView' and check the return 
					{
						# If the move is succesful then it will create the new node on the TreeView, expand the tree, and remove the old Node.
						$destinationNode.Nodes.Add($newNode.Clone())
						$destinationNode.ExpandAll()
						$newNode.Remove()
					} # endif
				} # endif 
				elseif ($newNode.Tag -like "Folder.*") # IF the node being moved is a folder
				{
					if (Move-SCSMFolder -folderID $newNode.Tag -newParentID $destinationNode.Tag) # Performs a move by calling 'Move-SCSMFolder' and check the return
					{
						# If the move is successful then it will create the new node on the TreeView, expand the tree, and remove the old Node.
						$destinationNode.Nodes.Add($newNode.Clone())
						$destinationNode.ExpandAll()
						$newNode.Remove()
					} # endif
				} # endelseif
			} # endif
		} # endif
	} # endevent
	
	<#
		DragOver Event
	#>
	$ManagementPackViews_DragOver=[System.Windows.Forms.DragEventHandler]{
		#Event Argument: $_ = [System.Windows.Forms.DragEventArgs]
		# Get the Node in the mouse position
		$position = $ManagementPackViews.PointToClient((New-Object System.Drawing.Point($_.X, $_.Y)))
		$destinationNode = $ManagementPackViews.GetNodeAt($position)
		<#
			Check the following:
				DestinationNode is not a View
				DestinationNode is not the same as the current folder 
				DestinationNode is not a subfolder of the parent node
		#>
		if (($destinationNode.Tag -notlike "View.*") -and ($destinationNode.Tag -ne $newNode.Tag) -and ($newNode.Nodes -notcontains $destinationNode))
		{
			# Show the allowed effect
			$_.Effect = $_.AllowedEffect
			# Select the node you are hovering above
			$DragPoint = $ManagementPackViews.PointToClient((New-Object System.Drawing.Point($_.X, $_.Y)))
			$ManagementPackViews.SelectedNode = $ManagementPackViews.GetNodeAt($DragPoint)
		}
	}
	
	<#
		Click Event on New Folder menuToolStrip
	#>
	$newFolderToolStripMenuItem_Click = {
		Clone-Folder $ManagementPackViews.SelectedNode $ManagementPackViews.SelectedNode.Parent
	}
	
	<#
		Click Event on Clone Folder mainToolStrip
	#>
	$cloneFolderMainToolStripMenuItem_Click = {
		Clone-Folder $ManagementPackViews.SelectedNode $ManagementPackViews.SelectedNode.Parent
	}
	
	<#
		Click Event on Delete Folder mainToolStrip
	#>
	$deleteViewMainToolStripMenuItem_Click = {
		Remove-View
	}
	
	<#
		Click Event on Delete Folder menuToolStrip
	#>
	$deleteFolderToolStripMenuItem_Click={
		Remove-Folder
	}
	
	<#
		Click Event on Delete View menuToolStrip
	#>
	$deleteViewToolStripMenuItem_Click={
		Remove-View 
	}
	
	<#
		Click Event on Delete View mainToolStrip
	#>
	$deleteFolderMainToolStripMenuItem1_Click={
		Remove-Folder
	}
	
	<#
		Click Event on Rename View mainToolStrip
	#>
	$renameViewMainToolStripMenuItem_Click={
		Rename-Item 
	}
	
	<#
		Click Event on Rename View menuToolStrip
	#>
	$renameViewToolStripMenuItem_Click={
		Rename-Item
	}
	
	<#
		Click Event on Rename Folder menuToolStrip
	#>
	$renameFolderToolStripMenuItem_Click={
		Rename-Item
	}
	
	<#
		DoubleClick Event on Node
	#>
	$ManagementPackViews_NodeMouseDoubleClick=[System.Windows.Forms.TreeNodeMouseClickEventHandler]{
		#Event Argument: $_ = [System.Windows.Forms.TreeNodeMouseClickEventArgs]
		Rename-Item
	}
	
	<#
		Click Event on New Folder mainToolStrip
	#>
	$newFolderMainToolStrip_Click={
		New-Folder
	}
	
	<#
		Click Event on New Folder menuToolStrip
	#>
	$newFolderToolStrip_Click={
		New-Folder
	}
	
	<#
		Click Event on New Folder from template mainToolStrip
	#>
	$newFolderFromTemplateToolStripMenuItem_Click={
		Create-FolderFromTemplate
	}
	
	<#
		Event AfterExpand 
	#>
	$ManagementPackViews_AfterExpand=[System.Windows.Forms.TreeViewEventHandler]{
		#Event Argument: $_ = [System.Windows.Forms.TreeViewEventArgs]
		# Change the image index if the folder is expanded
		$_.Node.ImageIndex = 1
		$_.Node.SelectedImageIndex = $_.Node.ImageIndex
	}
	
	<#
		Event AfterCollapse
	#>
	$ManagementPackViews_AfterCollapse=[System.Windows.Forms.TreeViewEventHandler]{
		#Event Argument: $_ = [System.Windows.Forms.TreeViewEventArgs]
		# Change the image index if the folder is collapsed
		$_.Node.ImageIndex = 0
		$_.Node.SelectedImageIndex = $_.Node.ImageIndex
	}
		# --End User Generated Script--
	#----------------------------------------------
	#region Generated Events
	#----------------------------------------------
	
	$Form_StateCorrection_Load=
	{
		#Correct the initial state of the form to prevent the .Net maximized form issue
		$SCSM_ViewManager.WindowState = $InitialFormWindowState
	}
	
	$Form_StoreValues_Closing=
	{
		#Store the control values
		if($ManagementPackViews.SelectedNode -ne $null)
		{
			$script:View_Manager_ManagementPackViews = $ManagementPackViews.SelectedNode.Text
		}
		else
		{
			$script:View_Manager_ManagementPackViews = $null
		}
	}

	
	$Form_Cleanup_FormClosed=
	{
		#Remove all event handlers from the controls
		try
		{
			$ManagementPackViews.remove_AfterCollapse($ManagementPackViews_AfterCollapse)
			$ManagementPackViews.remove_AfterExpand($ManagementPackViews_AfterExpand)
			$ManagementPackViews.remove_ItemDrag($ManagementPackViews_ItemDrag)
			$ManagementPackViews.remove_AfterSelect($ManagementPackViews_AfterSelect)
			$ManagementPackViews.remove_NodeMouseClick($ManagementPackViews_NodeMouseClick)
			$ManagementPackViews.remove_NodeMouseDoubleClick($ManagementPackViews_NodeMouseDoubleClick)
			$ManagementPackViews.remove_DragDrop($ManagementPackViews_DragDrop)
			$ManagementPackViews.remove_DragOver($ManagementPackViews_DragOver)
			$SCSM_ViewManager.remove_Load($SCSM_ViewManager_Load)
			$loadManagementPackToolStripMenuItem.remove_Click($loadManagementPackToolStripMenuItem_Click)
			$unloadManagementPackToolStripMenuItem.remove_Click($unloadManagementPackToolStripMenuItem_Click)
			$exitToolStripMenuItem.remove_Click($exitToolStripMenuItem_Click)
			$copyViewToolStripMenuItem.remove_Click($copyViewToolStripMenuItem_Click)
			$copyViewMainToolStripMenuItem.remove_Click($copyViewMainToolStripMenuItem_Click)
			$newFolderToolStripMenuItem.remove_Click($newFolderToolStripMenuItem_Click)
			$cloneFolderMainToolStripMenuItem.remove_Click($cloneFolderMainToolStripMenuItem_Click)
			$deleteViewMainToolStripMenuItem.remove_Click($deleteViewMainToolStripMenuItem_Click)
			$deleteFolderToolStripMenuItem.remove_Click($deleteFolderToolStripMenuItem_Click)
			$deleteFolderMainToolStripMenuItem1.remove_Click($deleteFolderMainToolStripMenuItem1_Click)
			$deleteViewToolStripMenuItem.remove_Click($deleteViewToolStripMenuItem_Click)
			$renameViewMainToolStripMenuItem.remove_Click($renameViewMainToolStripMenuItem_Click)
			$renameViewToolStripMenuItem.remove_Click($renameViewToolStripMenuItem_Click)
			$renameFolderToolStripMenuItem.remove_Click($renameFolderToolStripMenuItem_Click)
			$newFolderMainToolStrip.remove_Click($newFolderMainToolStrip_Click)
			$newFolderToolStrip.remove_Click($newFolderToolStrip_Click)
			$newFolderFromTemplateToolStripMenuItem.remove_Click($newFolderFromTemplateToolStripMenuItem_Click)
			$SCSM_ViewManager.remove_Load($Form_StateCorrection_Load)
			$SCSM_ViewManager.remove_Closing($Form_StoreValues_Closing)
			$SCSM_ViewManager.remove_FormClosed($Form_Cleanup_FormClosed)
		}
		catch [Exception]
		{ }
	}
	#endregion Generated Events

	#----------------------------------------------
	#region Generated Form Code
	#----------------------------------------------
	$SCSM_ViewManager.SuspendLayout()
	$menustrip1.SuspendLayout()
	$viewContextMenu.SuspendLayout()
	$folderContextMenu.SuspendLayout()
	#
	# SCSM_ViewManager
	#
	$SCSM_ViewManager.Controls.Add($loadingBar)
	$SCSM_ViewManager.Controls.Add($propertygrid1)
	$SCSM_ViewManager.Controls.Add($statusbar1)
	$SCSM_ViewManager.Controls.Add($ManagementPackViews)
	$SCSM_ViewManager.Controls.Add($menustrip1)
	$SCSM_ViewManager.AllowDrop = $True
	$SCSM_ViewManager.ClientSize = '983, 611'
	$SCSM_ViewManager.FormBorderStyle = 'FixedSingle'
	#region Binary Data
	$SCSM_ViewManager.Icon = [System.Convert]::FromBase64String('
AAABAAEAEBAQAAEABAAoAQAAFgAAACgAAAAQAAAAIAAAAAEABAAAAAAAgAAAAAAAAAAAAAAAEAAA
AAAAAADw9vwA////AABmzABgoN8AwNnyACB50gCAs+YA4Oz5AJC86QBAjNkAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAIiIiIiIiIiJWZiIilmMiIpERIiJhFCIikREiImEUIiKRESIiYRQiIpERIiJh
FCIikREiImEUIiKRESIiYRQiIpERIiJhFCIikREiImEUIiKRESIiYRQiIpERIiJhFCIikREoRHEQ
REKRESQRERERElZmI2ZmZmZiIiIiIiIiIiIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA')
	#endregion
	$SCSM_ViewManager.MainMenuStrip = $menustrip1
	$SCSM_ViewManager.MaximizeBox = $False
	$SCSM_ViewManager.Name = 'SCSM_ViewManager'
	$SCSM_ViewManager.SizeGripStyle = 'Hide'
	$SCSM_ViewManager.Text = 'View Manager'
	$SCSM_ViewManager.add_Load($SCSM_ViewManager_Load)
	#
	# loadingBar
	#
	$loadingBar.Location = '419, 522'
	$loadingBar.Name = 'loadingBar'
	$loadingBar.Size = '552, 61'
	$loadingBar.TabIndex = 9
	$loadingBar.Visible = $False
	#
	# propertygrid1
	#
	$propertygrid1.CategoryForeColor = 'InactiveCaptionText'
	$propertygrid1.Location = '419, 27'
	$propertygrid1.Name = 'propertygrid1'
	$propertygrid1.Size = '552, 556'
	$propertygrid1.TabIndex = 6
	#
	# statusbar1
	#
	$statusbar1.Location = '0, 589'
	$statusbar1.Name = 'statusbar1'
	$statusbar1.Size = '983, 22'
	$statusbar1.TabIndex = 3
	$statusbar1.Text = 'Management Pack :: NotLoaded'
	#
	# ManagementPackViews
	#
	$ManagementPackViews.AllowDrop = $True
	$ManagementPackViews.ContextMenuStrip = $folderContextMenu
	$ManagementPackViews.ImageIndex = 0
	$ManagementPackViews.ImageList = $imagelist1
	$ManagementPackViews.Location = '12, 27'
	$ManagementPackViews.Name = 'ManagementPackViews'
	$ManagementPackViews.SelectedImageIndex = 0
	$ManagementPackViews.Size = '401, 556'
	$ManagementPackViews.TabIndex = 0
	$ManagementPackViews.add_AfterCollapse($ManagementPackViews_AfterCollapse)
	$ManagementPackViews.add_AfterExpand($ManagementPackViews_AfterExpand)
	$ManagementPackViews.add_ItemDrag($ManagementPackViews_ItemDrag)
	$ManagementPackViews.add_AfterSelect($ManagementPackViews_AfterSelect)
	$ManagementPackViews.add_NodeMouseClick($ManagementPackViews_NodeMouseClick)
	$ManagementPackViews.add_NodeMouseDoubleClick($ManagementPackViews_NodeMouseDoubleClick)
	$ManagementPackViews.add_DragDrop($ManagementPackViews_DragDrop)
	$ManagementPackViews.add_DragOver($ManagementPackViews_DragOver)
	#
	# menustrip1
	#
	[void]$menustrip1.Items.Add($fileToolStripMenuItem)
	[void]$menustrip1.Items.Add($editToolStripMenuItem)
	$menustrip1.Location = '0, 0'
	$menustrip1.Name = 'menustrip1'
	$menustrip1.Size = '983, 24'
	$menustrip1.TabIndex = 5
	$menustrip1.Text = 'menustrip1'
	#
	# fileToolStripMenuItem
	#
	[void]$fileToolStripMenuItem.DropDownItems.Add($loadManagementPackToolStripMenuItem)
	[void]$fileToolStripMenuItem.DropDownItems.Add($unloadManagementPackToolStripMenuItem)
	[void]$fileToolStripMenuItem.DropDownItems.Add($toolstripseparator2)
	[void]$fileToolStripMenuItem.DropDownItems.Add($exitToolStripMenuItem)
	$fileToolStripMenuItem.Name = 'fileToolStripMenuItem'
	$fileToolStripMenuItem.Size = '37, 20'
	$fileToolStripMenuItem.Text = 'File'
	#
	# loadManagementPackToolStripMenuItem
	#
	$loadManagementPackToolStripMenuItem.Name = 'loadManagementPackToolStripMenuItem'
	$loadManagementPackToolStripMenuItem.Size = '214, 22'
	$loadManagementPackToolStripMenuItem.Text = 'Load Management Pack'
	$loadManagementPackToolStripMenuItem.add_Click($loadManagementPackToolStripMenuItem_Click)
	#
	# unloadManagementPackToolStripMenuItem
	#
	$unloadManagementPackToolStripMenuItem.Name = 'unloadManagementPackToolStripMenuItem'
	$unloadManagementPackToolStripMenuItem.Size = '214, 22'
	$unloadManagementPackToolStripMenuItem.Text = 'Unload Management Pack'
	$unloadManagementPackToolStripMenuItem.add_Click($unloadManagementPackToolStripMenuItem_Click)
	#
	# exitToolStripMenuItem
	#
	$exitToolStripMenuItem.Name = 'exitToolStripMenuItem'
	$exitToolStripMenuItem.Size = '214, 22'
	$exitToolStripMenuItem.Text = 'Exit'
	$exitToolStripMenuItem.add_Click($exitToolStripMenuItem_Click)
	#
	# viewContextMenu
	#
	[void]$viewContextMenu.Items.Add($copyViewToolStripMenuItem)
	[void]$viewContextMenu.Items.Add($deleteViewToolStripMenuItem)
	[void]$viewContextMenu.Items.Add($renameViewToolStripMenuItem)
	$viewContextMenu.Name = 'viewContextMenu'
	$viewContextMenu.Size = '136, 48'
	#
	# folderContextMenu
	#
	[void]$folderContextMenu.Items.Add($newFolderToolStripMenuItem)
	[void]$folderContextMenu.Items.Add($deleteFolderToolStripMenuItem)
	[void]$folderContextMenu.Items.Add($renameFolderToolStripMenuItem)
	[void]$folderContextMenu.Items.Add($newFolderToolStrip)
	$folderContextMenu.Name = 'folderContextMenu'
	$folderContextMenu.Size = '154, 70'
	#
	# editToolStripMenuItem
	#
	[void]$editToolStripMenuItem.DropDownItems.Add($viewToolStripMenuItem)
	[void]$editToolStripMenuItem.DropDownItems.Add($folderToolStripMenuItem)
	$editToolStripMenuItem.Name = 'editToolStripMenuItem'
	$editToolStripMenuItem.Size = '39, 20'
	$editToolStripMenuItem.Text = 'Edit'
	#
	# viewToolStripMenuItem
	#
	[void]$viewToolStripMenuItem.DropDownItems.Add($copyViewMainToolStripMenuItem)
	[void]$viewToolStripMenuItem.DropDownItems.Add($deleteViewMainToolStripMenuItem)
	[void]$viewToolStripMenuItem.DropDownItems.Add($renameViewMainToolStripMenuItem)
	$viewToolStripMenuItem.Name = 'viewToolStripMenuItem'
	$viewToolStripMenuItem.Size = '99, 22'
	$viewToolStripMenuItem.Text = 'View'
	#
	# folderToolStripMenuItem
	#
	[void]$folderToolStripMenuItem.DropDownItems.Add($cloneFolderMainToolStripMenuItem)
	[void]$folderToolStripMenuItem.DropDownItems.Add($deleteFolderMainToolStripMenuItem1)
	[void]$folderToolStripMenuItem.DropDownItems.Add($renameFolderMainToolStripMenuItem)
	[void]$folderToolStripMenuItem.DropDownItems.Add($newFolderMainToolStrip)
	[void]$folderToolStripMenuItem.DropDownItems.Add($newFolderFromTemplateToolStripMenuItem)
	$folderToolStripMenuItem.Name = 'folderToolStripMenuItem'
	$folderToolStripMenuItem.Size = '152, 22'
	$folderToolStripMenuItem.Text = 'Folder'
	#
	# copyViewToolStripMenuItem
	#
	$copyViewToolStripMenuItem.Name = 'copyViewToolStripMenuItem'
	$copyViewToolStripMenuItem.Size = '135, 22'
	$copyViewToolStripMenuItem.Text = 'Copy View'
	$copyViewToolStripMenuItem.add_Click($copyViewToolStripMenuItem_Click)
	#
	# copyViewMainToolStripMenuItem
	#
	$copyViewMainToolStripMenuItem.Name = 'copyViewMainToolStripMenuItem'
	$copyViewMainToolStripMenuItem.Size = '135, 22'
	$copyViewMainToolStripMenuItem.Text = 'Copy View'
	$copyViewMainToolStripMenuItem.add_Click($copyViewMainToolStripMenuItem_Click)
	#
	# newFolderToolStripMenuItem
	#
	$newFolderToolStripMenuItem.Name = 'newFolderToolStripMenuItem'
	$newFolderToolStripMenuItem.Size = '153, 22'
	$newFolderToolStripMenuItem.Text = 'Clone Folder'
	$newFolderToolStripMenuItem.add_Click($newFolderToolStripMenuItem_Click)
	#
	# cloneFolderMainToolStripMenuItem
	#
	$cloneFolderMainToolStripMenuItem.Name = 'cloneFolderMainToolStripMenuItem'
	$cloneFolderMainToolStripMenuItem.Size = '153, 22'
	$cloneFolderMainToolStripMenuItem.Text = 'Clone Folder'
	$cloneFolderMainToolStripMenuItem.add_Click($cloneFolderMainToolStripMenuItem_Click)
	#
	# toolstripseparator2
	#
	$toolstripseparator2.Name = 'toolstripseparator2'
	$toolstripseparator2.Size = '211, 6'
	#
	# deleteViewMainToolStripMenuItem
	#
	$deleteViewMainToolStripMenuItem.Name = 'deleteViewMainToolStripMenuItem'
	$deleteViewMainToolStripMenuItem.Size = '135, 22'
	$deleteViewMainToolStripMenuItem.Text = 'Delete View'
	$deleteViewMainToolStripMenuItem.add_Click($deleteViewMainToolStripMenuItem_Click)
	#
	# deleteFolderToolStripMenuItem
	#
	$deleteFolderToolStripMenuItem.Name = 'deleteFolderToolStripMenuItem'
	$deleteFolderToolStripMenuItem.Size = '153, 22'
	$deleteFolderToolStripMenuItem.Text = 'Delete Folder'
	$deleteFolderToolStripMenuItem.add_Click($deleteFolderToolStripMenuItem_Click)
	#
	# deleteFolderMainToolStripMenuItem1
	#
	$deleteFolderMainToolStripMenuItem1.Name = 'deleteFolderMainToolStripMenuItem1'
	$deleteFolderMainToolStripMenuItem1.Size = '153, 22'
	$deleteFolderMainToolStripMenuItem1.Text = 'Delete Folder'
	$deleteFolderMainToolStripMenuItem1.add_Click($deleteFolderMainToolStripMenuItem1_Click)
	#
	# deleteViewToolStripMenuItem
	#
	$deleteViewToolStripMenuItem.Name = 'deleteViewToolStripMenuItem'
	$deleteViewToolStripMenuItem.Size = '135, 22'
	$deleteViewToolStripMenuItem.Text = 'Delete View'
	$deleteViewToolStripMenuItem.add_Click($deleteViewToolStripMenuItem_Click)
	#
	# renameViewMainToolStripMenuItem
	#
	$renameViewMainToolStripMenuItem.Name = 'renameViewMainToolStripMenuItem'
	$renameViewMainToolStripMenuItem.Size = '152, 22'
	$renameViewMainToolStripMenuItem.Text = 'Rename View'
	$renameViewMainToolStripMenuItem.add_Click($renameViewMainToolStripMenuItem_Click)
	#
	# renameFolderMainToolStripMenuItem
	#
	$renameFolderMainToolStripMenuItem.Name = 'renameFolderMainToolStripMenuItem'
	$renameFolderMainToolStripMenuItem.Size = '153, 22'
	$renameFolderMainToolStripMenuItem.Text = 'Rename Folder'
	#
	# renameViewToolStripMenuItem
	#
	$renameViewToolStripMenuItem.Name = 'renameViewToolStripMenuItem'
	$renameViewToolStripMenuItem.Size = '145, 22'
	$renameViewToolStripMenuItem.Text = 'Rename View'
	$renameViewToolStripMenuItem.add_Click($renameViewToolStripMenuItem_Click)
	#
	# renameFolderToolStripMenuItem
	#
	$renameFolderToolStripMenuItem.Name = 'renameFolderToolStripMenuItem'
	$renameFolderToolStripMenuItem.Size = '153, 22'
	$renameFolderToolStripMenuItem.Text = 'Rename Folder'
	$renameFolderToolStripMenuItem.add_Click($renameFolderToolStripMenuItem_Click)
	#
	# newFolderMainToolStrip
	#
	$newFolderMainToolStrip.Name = 'newFolderMainToolStrip'
	$newFolderMainToolStrip.Size = '153, 22'
	$newFolderMainToolStrip.Text = 'New Folder'
	$newFolderMainToolStrip.add_Click($newFolderMainToolStrip_Click)
	#
	# newFolderToolStrip
	#
	$newFolderToolStrip.Name = 'newFolderToolStrip'
	$newFolderToolStrip.Size = '153, 22'
	$newFolderToolStrip.Text = 'New Folder'
	$newFolderToolStrip.add_Click($newFolderToolStrip_Click)
	#
	# newFolderFromTemplateToolStripMenuItem
	#
	$newFolderFromTemplateToolStripMenuItem.Name = 'newFolderFromTemplateToolStripMenuItem'
	$newFolderFromTemplateToolStripMenuItem.Size = '218, 22'
	$newFolderFromTemplateToolStripMenuItem.Text = 'New Folder From Template'
	$newFolderFromTemplateToolStripMenuItem.add_Click($newFolderFromTemplateToolStripMenuItem_Click)
	#
	# imagelist1
	#
	$Formatter_binaryFomatter = New-Object System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
	#region Binary Data
	$System_IO_MemoryStream = New-Object System.IO.MemoryStream (,[byte[]][System.Convert]::FromBase64String('
AAEAAAD/////AQAAAAAAAAAMAgAAAFdTeXN0ZW0uV2luZG93cy5Gb3JtcywgVmVyc2lvbj00LjAu
MC4wLCBDdWx0dXJlPW5ldXRyYWwsIFB1YmxpY0tleVRva2VuPWI3N2E1YzU2MTkzNGUwODkFAQAA
ACZTeXN0ZW0uV2luZG93cy5Gb3Jtcy5JbWFnZUxpc3RTdHJlYW1lcgEAAAAERGF0YQcCAgAAAAkD
AAAADwMAAAAOCQAAAk1TRnQBSQFMAgEBAwEAARgBAAEYAQABEAEAARABAAT/AQkBAAj/AUIBTQE2
AQQGAAE2AQQCAAEoAwABQAMAARADAAEBAQABCAYAAQQYAAGAAgABgAMAAoABAAGAAwABgAEAAYAB
AAKAAgADwAEAAcAB3AHAAQAB8AHKAaYBAAEzBQABMwEAATMBAAEzAQACMwIAAxYBAAMcAQADIgEA
AykBAANVAQADTQEAA0IBAAM5AQABgAF8Af8BAAJQAf8BAAGTAQAB1gEAAf8B7AHMAQABxgHWAe8B
AAHWAucBAAGQAakBrQIAAf8BMwMAAWYDAAGZAwABzAIAATMDAAIzAgABMwFmAgABMwGZAgABMwHM
AgABMwH/AgABZgMAAWYBMwIAAmYCAAFmAZkCAAFmAcwCAAFmAf8CAAGZAwABmQEzAgABmQFmAgAC
mQIAAZkBzAIAAZkB/wIAAcwDAAHMATMCAAHMAWYCAAHMAZkCAALMAgABzAH/AgAB/wFmAgAB/wGZ
AgAB/wHMAQABMwH/AgAB/wEAATMBAAEzAQABZgEAATMBAAGZAQABMwEAAcwBAAEzAQAB/wEAAf8B
MwIAAzMBAAIzAWYBAAIzAZkBAAIzAcwBAAIzAf8BAAEzAWYCAAEzAWYBMwEAATMCZgEAATMBZgGZ
AQABMwFmAcwBAAEzAWYB/wEAATMBmQIAATMBmQEzAQABMwGZAWYBAAEzApkBAAEzAZkBzAEAATMB
mQH/AQABMwHMAgABMwHMATMBAAEzAcwBZgEAATMBzAGZAQABMwLMAQABMwHMAf8BAAEzAf8BMwEA
ATMB/wFmAQABMwH/AZkBAAEzAf8BzAEAATMC/wEAAWYDAAFmAQABMwEAAWYBAAFmAQABZgEAAZkB
AAFmAQABzAEAAWYBAAH/AQABZgEzAgABZgIzAQABZgEzAWYBAAFmATMBmQEAAWYBMwHMAQABZgEz
Af8BAAJmAgACZgEzAQADZgEAAmYBmQEAAmYBzAEAAWYBmQIAAWYBmQEzAQABZgGZAWYBAAFmApkB
AAFmAZkBzAEAAWYBmQH/AQABZgHMAgABZgHMATMBAAFmAcwBmQEAAWYCzAEAAWYBzAH/AQABZgH/
AgABZgH/ATMBAAFmAf8BmQEAAWYB/wHMAQABzAEAAf8BAAH/AQABzAEAApkCAAGZATMBmQEAAZkB
AAGZAQABmQEAAcwBAAGZAwABmQIzAQABmQEAAWYBAAGZATMBzAEAAZkBAAH/AQABmQFmAgABmQFm
ATMBAAGZATMBZgEAAZkBZgGZAQABmQFmAcwBAAGZATMB/wEAApkBMwEAApkBZgEAA5kBAAKZAcwB
AAKZAf8BAAGZAcwCAAGZAcwBMwEAAWYBzAFmAQABmQHMAZkBAAGZAswBAAGZAcwB/wEAAZkB/wIA
AZkB/wEzAQABmQHMAWYBAAGZAf8BmQEAAZkB/wHMAQABmQL/AQABzAMAAZkBAAEzAQABzAEAAWYB
AAHMAQABmQEAAcwBAAHMAQABmQEzAgABzAIzAQABzAEzAWYBAAHMATMBmQEAAcwBMwHMAQABzAEz
Af8BAAHMAWYCAAHMAWYBMwEAAZkCZgEAAcwBZgGZAQABzAFmAcwBAAGZAWYB/wEAAcwBmQIAAcwB
mQEzAQABzAGZAWYBAAHMApkBAAHMAZkBzAEAAcwBmQH/AQACzAIAAswBMwEAAswBZgEAAswBmQEA
A8wBAALMAf8BAAHMAf8CAAHMAf8BMwEAAZkB/wFmAQABzAH/AZkBAAHMAf8BzAEAAcwC/wEAAcwB
AAEzAQAB/wEAAWYBAAH/AQABmQEAAcwBMwIAAf8CMwEAAf8BMwFmAQAB/wEzAZkBAAH/ATMBzAEA
Af8BMwH/AQAB/wFmAgAB/wFmATMBAAHMAmYBAAH/AWYBmQEAAf8BZgHMAQABzAFmAf8BAAH/AZkC
AAH/AZkBMwEAAf8BmQFmAQAB/wKZAQAB/wGZAcwBAAH/AZkB/wEAAf8BzAIAAf8BzAEzAQAB/wHM
AWYBAAH/AcwBmQEAAf8CzAEAAf8BzAH/AQAC/wEzAQABzAH/AWYBAAL/AZkBAAL/AcwBAAJmAf8B
AAFmAf8BZgEAAWYC/wEAAf8CZgEAAf8BZgH/AQAC/wFmAQABIQEAAaUBAANfAQADdwEAA4YBAAOW
AQADywEAA7IBAAPXAQAD3QEAA+MBAAPqAQAD8QEAA/gBAAHwAfsB/wEAAaQCoAEAA4ADAAH/AgAB
/wMAAv8BAAH/AwAB/wEAAf8BAAL/AgAD/wEAAf8O9BH/IAABCQ60AQkQ/wFyDSgBchEAAbQB3AzW
AdwBtA4HAv8BKAX/AvYB/wH2A/QB8wEoEQABtAHcDNYB3AG0AbwMtAHwAv8BSQH/AXIB/wNyAfQB
cgEbA3IBGwFJEQABtA7cArQBCQvcAbsC/wFKAv8B9gH/AfYB9AHzBhsBShEAAbQO3AK0AQkB3ArW
AbQC/wFKAf8BcgH/A3IBGwFyARsDcgEbAUoRAAG0DtwDtAEJCtwBtQHdAf8BUAH2Af8B9gH0AfMG
GwEaARsBUBEAAbUBCQzcAQkBtQK0AQkL3AG1Af8BUAH2AXIB9ANyARsBcgEbA3IBGwFQEQABtQHc
BQkH3AEJAbUDtAEJCtwBtQHzAVAB/wH0AfMGGwIaAQgBGwFQEQABtQcJB9wBtQG0AbsCtAH0ChkB
8AFQAfYBcgEbA3IBGwFyARoDcgEbAVARAAi1AQkG3AG1AbQB3AG1CrQBvAHwAfQBcgH2A/QB8wgb
AXIRAAHvAfQF8gEJAbUGCQG1AbQBCQTcBgkBtQH0Av8OcwFyEQAB8QHvBv8Buwa1AfEBtAH0BBkH
tQP/AXINmQFyEgAB8QbvAfEHAAEJBbUK/wFzDZkBcyEAEP8BCA1zAQghABD/IAABQgFNAT4HAAE+
AwABKAMAAUADAAEQAwABAQEAAQEFAAGAFwAD/wUAAv8HAAEBBwABAQcAAQEHAAEBBwABAQcAAQEH
AAEBBwABAQcAAQEHAAEBBwABAQcAAQECAAGAAX8DAAEBAgAC/wMAAQECAAL/AgAC/wIACw=='))
	#endregion
	$imagelist1.ImageStream = $Formatter_binaryFomatter.Deserialize($System_IO_MemoryStream)
	$Formatter_binaryFomatter = $null
	$System_IO_MemoryStream = $null
	$imagelist1.TransparentColor = 'Transparent'
	$folderContextMenu.ResumeLayout()
	$viewContextMenu.ResumeLayout()
	$menustrip1.ResumeLayout()
	$SCSM_ViewManager.ResumeLayout()
	#endregion Generated Form Code

	#----------------------------------------------

	#Save the initial state of the form
	$InitialFormWindowState = $SCSM_ViewManager.WindowState
	#Init the OnLoad event to correct the initial state of the form
	$SCSM_ViewManager.add_Load($Form_StateCorrection_Load)
	#Clean up the control events
	$SCSM_ViewManager.add_FormClosed($Form_Cleanup_FormClosed)
	#Store the control values when form is closing
	$SCSM_ViewManager.add_Closing($Form_StoreValues_Closing)
	#Show the Form
	return $SCSM_ViewManager.ShowDialog()

}
#endregion Source: View Manager.psf

#region Source: EnterNewViewName.psf
function Call-EnterNewViewName_psf
{
	#----------------------------------------------
	#region Import the Assemblies
	#----------------------------------------------
	[void][reflection.assembly]::Load('System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089')
	[void][reflection.assembly]::Load('System.Data, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089')
	[void][reflection.assembly]::Load('System.Drawing, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a')
	[void][reflection.assembly]::Load('System.DirectoryServices, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a')
	[void][reflection.assembly]::Load('System.ServiceProcess, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a')
	#endregion Import Assemblies

	#----------------------------------------------
	#region Generated Form Objects
	#----------------------------------------------
	[System.Windows.Forms.Application]::EnableVisualStyles()
	$newNameForm = New-Object 'System.Windows.Forms.Form'
	$newName_txtBox = New-Object 'System.Windows.Forms.TextBox'
	$buttonOK = New-Object 'System.Windows.Forms.Button'
	$InitialFormWindowState = New-Object 'System.Windows.Forms.FormWindowState'
	#endregion Generated Form Objects

	#----------------------------------------------
	# User Generated Script
	#----------------------------------------------
	
	$newNameForm_Load={
		#TODO: Initialize Form Controls here
		
	}
		# --End User Generated Script--
	#----------------------------------------------
	#region Generated Events
	#----------------------------------------------
	
	$Form_StateCorrection_Load=
	{
		#Correct the initial state of the form to prevent the .Net maximized form issue
		$newNameForm.WindowState = $InitialFormWindowState
	}
	
	$Form_StoreValues_Closing=
	{
		#Store the control values
		$script:EnterNewViewName_newName_txtBox = $newName_txtBox.Text
	}

	
	$Form_Cleanup_FormClosed=
	{
		#Remove all event handlers from the controls
		try
		{
			$newNameForm.remove_Load($newNameForm_Load)
			$newNameForm.remove_Load($Form_StateCorrection_Load)
			$newNameForm.remove_Closing($Form_StoreValues_Closing)
			$newNameForm.remove_FormClosed($Form_Cleanup_FormClosed)
		}
		catch [Exception]
		{ }
	}
	#endregion Generated Events

	#----------------------------------------------
	#region Generated Form Code
	#----------------------------------------------
	$newNameForm.SuspendLayout()
	#
	# newNameForm
	#
	$newNameForm.Controls.Add($newName_txtBox)
	$newNameForm.Controls.Add($buttonOK)
	$newNameForm.AcceptButton = $buttonOK
	$newNameForm.ClientSize = '362, 78'
	$newNameForm.FormBorderStyle = 'FixedDialog'
	#region Binary Data
	$newNameForm.Icon = [System.Convert]::FromBase64String('
AAABAAEAEBAQAAEABAAoAQAAFgAAACgAAAAQAAAAIAAAAAEABAAAAAAAgAAAAAAAAAAAAAAAEAAA
AAAAAADw9vwA////AABmzABgoN8AwNnyACB50gCAs+YA4Oz5AJC86QBAjNkAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAIiIiIiIiIiJWZiIilmMiIpERIiJhFCIikREiImEUIiKRESIiYRQiIpERIiJh
FCIikREiImEUIiKRESIiYRQiIpERIiJhFCIikREiImEUIiKRESIiYRQiIpERIiJhFCIikREoRHEQ
REKRESQRERERElZmI2ZmZmZiIiIiIiIiIiIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA')
	#endregion
	$newNameForm.MaximizeBox = $False
	$newNameForm.MinimizeBox = $False
	$newNameForm.Name = 'newNameForm'
	$newNameForm.SizeGripStyle = 'Hide'
	$newNameForm.StartPosition = 'CenterScreen'
	$newNameForm.Text = 'Enter new name'
	$newNameForm.add_Load($newNameForm_Load)
	#
	# newName_txtBox
	#
	$newName_txtBox.Location = '12, 13'
	$newName_txtBox.Name = 'newName_txtBox'
	$newName_txtBox.Size = '338, 20'
	$newName_txtBox.TabIndex = 0
	#
	# buttonOK
	#
	$buttonOK.Anchor = 'Bottom, Right'
	$buttonOK.DialogResult = 'OK'
	$buttonOK.Location = '134, 43'
	$buttonOK.Name = 'buttonOK'
	$buttonOK.Size = '75, 23'
	$buttonOK.TabIndex = 1
	$buttonOK.Text = '&OK'
	$buttonOK.UseVisualStyleBackColor = $True
	$newNameForm.ResumeLayout()
	#endregion Generated Form Code

	#----------------------------------------------

	#Save the initial state of the form
	$InitialFormWindowState = $newNameForm.WindowState
	#Init the OnLoad event to correct the initial state of the form
	$newNameForm.add_Load($Form_StateCorrection_Load)
	#Clean up the control events
	$newNameForm.add_FormClosed($Form_Cleanup_FormClosed)
	#Store the control values when form is closing
	$newNameForm.add_Closing($Form_StoreValues_Closing)
	#Show the Form
	return $newNameForm.ShowDialog()

}
#endregion Source: EnterNewViewName.psf

#region Source: EnterNewName.psf
function Call-EnterNewName_psf
{
param (
	[string]$selectedNodeName
)

	#----------------------------------------------
	#region Import the Assemblies
	#----------------------------------------------
	[void][reflection.assembly]::Load('System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089')
	[void][reflection.assembly]::Load('System.Data, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089')
	[void][reflection.assembly]::Load('System.Drawing, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a')
	[void][reflection.assembly]::Load('System.DirectoryServices, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a')
	[void][reflection.assembly]::Load('System.ServiceProcess, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a')
	#endregion Import Assemblies

	#----------------------------------------------
	#region Generated Form Objects
	#----------------------------------------------
	[System.Windows.Forms.Application]::EnableVisualStyles()
	$newNameForm = New-Object 'System.Windows.Forms.Form'
	$newName_TxtBox = New-Object 'System.Windows.Forms.TextBox'
	$buttonOK = New-Object 'System.Windows.Forms.Button'
	$InitialFormWindowState = New-Object 'System.Windows.Forms.FormWindowState'
	#endregion Generated Form Objects

	#----------------------------------------------
	# User Generated Script
	#----------------------------------------------
	
	$newNameForm_Load={
		$newName_TxtBox.Text = $selectedNodeName
	}
	
	# --End User Generated Script--
	#----------------------------------------------
	#region Generated Events
	#----------------------------------------------
	
	$Form_StateCorrection_Load=
	{
		#Correct the initial state of the form to prevent the .Net maximized form issue
		$newNameForm.WindowState = $InitialFormWindowState
	}
	
	$Form_StoreValues_Closing=
	{
		#Store the control values
		$script:EnterNewName_newName_TxtBox = $newName_TxtBox.Text
	}

	
	$Form_Cleanup_FormClosed=
	{
		#Remove all event handlers from the controls
		try
		{
			$newNameForm.remove_Load($newNameForm_Load)
			$newNameForm.remove_Load($Form_StateCorrection_Load)
			$newNameForm.remove_Closing($Form_StoreValues_Closing)
			$newNameForm.remove_FormClosed($Form_Cleanup_FormClosed)
		}
		catch [Exception]
		{ }
	}
	#endregion Generated Events

	#----------------------------------------------
	#region Generated Form Code
	#----------------------------------------------
	$newNameForm.SuspendLayout()
	#
	# newNameForm
	#
	$newNameForm.Controls.Add($newName_TxtBox)
	$newNameForm.Controls.Add($buttonOK)
	$newNameForm.AcceptButton = $buttonOK
	$newNameForm.ClientSize = '284, 76'
	$newNameForm.FormBorderStyle = 'FixedDialog'
	$newNameForm.MaximizeBox = $False
	$newNameForm.MinimizeBox = $False
	$newNameForm.Name = 'newNameForm'
	$newNameForm.StartPosition = 'CenterScreen'
	$newNameForm.Text = 'Enter new name'
	$newNameForm.add_Load($newNameForm_Load)
	#
	# newName_TxtBox
	#
	$newName_TxtBox.Location = '12, 13'
	$newName_TxtBox.Name = 'newName_TxtBox'
	$newName_TxtBox.Size = '260, 20'
	$newName_TxtBox.TabIndex = 0
	#
	# buttonOK
	#
	$buttonOK.Anchor = 'Bottom, Right'
	$buttonOK.DialogResult = 'OK'
	$buttonOK.Location = '94, 39'
	$buttonOK.Name = 'buttonOK'
	$buttonOK.Size = '75, 23'
	$buttonOK.TabIndex = 1
	$buttonOK.Text = '&OK'
	$buttonOK.UseVisualStyleBackColor = $True
	$newNameForm.ResumeLayout()
	#endregion Generated Form Code

	#----------------------------------------------

	#Save the initial state of the form
	$InitialFormWindowState = $newNameForm.WindowState
	#Init the OnLoad event to correct the initial state of the form
	$newNameForm.add_Load($Form_StateCorrection_Load)
	#Clean up the control events
	$newNameForm.add_FormClosed($Form_Cleanup_FormClosed)
	#Store the control values when form is closing
	$newNameForm.add_Closing($Form_StoreValues_Closing)
	#Show the Form
	return $newNameForm.ShowDialog()

}
#endregion Source: EnterNewName.psf

#Start the application
Main ($CommandLine)
